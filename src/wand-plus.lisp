; (declaim (optimize (speed 0) (safety 3) (debug 3)))

(defpackage wand+
  (:use :cl :alexandria :let-plus :trivia))
(in-package :wand+)

;;=============================================================================

(defmacro ematch-form (m &body clauses)
  `(case (car ,m)
     ,@(map 'list
            #'(lambda (clause)
                (destructuring-bind ((ctag &rest args) &rest body) clause
                  `((,ctag) (destructuring-bind ,args (cdr ,m)
                              ,@body))))
            clauses)
     (t (error (format nil "(EIFT) Form tag not recognized: ~s" (car ,m))))))

(defparameter *gen-tvar-counter* 0)
(defun gen-tvar (&optional (n "A") (tag :tvar))
  "Generate a fresh new tvar"
  (let+ ((s (concatenate 'string
                         n
                         (write-to-string *gen-tvar-counter*)))
         (r (list tag (make-symbol s))))
    (incf *gen-tvar-counter*)
    r))
(defun gen-svar (&optional (n "A*"))
  "Generate a fresh new svar"
  (gen-tvar n :svar))

(defun strip-end-nums (str)
  (if (< 0 (length str))
      (loop for i from (1- (length str)) downto 0
            do (unless (digit-char-p (aref str i))
                 (return (subseq str 0 (1+ i))))
            finally (error (format nil "String ~s only contains numbers" str)))
      (error (format nil "String is empty"))))

(defun svar->str (svar)
  "Get a the svar name as a string without the
   trailing numbers generated by gen-tvar for uniqueness"
  (let ((s (string (second svar))))
    (strip-end-nums s)))

(defun tvar->str (tvar) (svar->str tvar))
(defun evar->str (evar) (svar->str evar))

(defun partition (pred l)
  "Filter a list into two lists.

   (if (pred element)
     (element to first list)
     (element to second list))"
  (let ((y '())
        (n '()))
    (dolist (x l)
      (if (funcall pred x)
          (push x y)
          (push x n)))
    (list
      (reverse y)
      (reverse n))))

(defun get-var? (varname assumptions)
  "Shortcut for (assoc x y :test #'equal"
  (assoc varname assumptions :test #'equal))

(defun get-var (varname assumptions)
  "Get var from assumptions or error if not found"
  (let ((ty? (get-var? varname assumptions)))
    (if ty?
        (cdr ty?)
        (error (format nil "(EVNIA): Variable type not in scope for ~s" varname)))))

;;=============================================================================

(defun wand (eqs si-eqs goals)

  ;; Goal = (A, M, t), where A = Assumptions  : ALIST (evar => tvar)
  ;;                         M = Expr Form    : EXPR
  ;;                         t = TVar of form : (:TVAR 'NAME)

  ;; IMPORTANT: the order of the s-constraints generated is significant
  (if goals
      (let+ (((a m ty) (car goals)))
        (ematch-form m
          ;; VARIABLE REFERENCE
          ((:evar n tty)
           (push (cons tty ty) eqs)
           (ematch-form (get-var (list :evar n) a)
             ;; TVAR (some type var)
             ((:tvar tn)
              (let ((new-eq (cons ty (list :tvar tn))))
                (wand (cons new-eq eqs) si-eqs (rest goals))))

             ;; SVAR (a to-be-instantiated bound tvar from a scheme)
             ((:svar tn)
              (let ((new-si-eq (list :i (list :svar tn) ty)))
                (wand eqs (cons new-si-eq si-eqs) (rest goals))))))

          ;; LITTERAL
          ((:lit tty _)
           (declare (ignore _))
           (let ((new-eq (cons ty tty)))
             (wand (cons new-eq eqs) si-eqs (rest goals))))

          ;; FUNCALL
          ((:call e1 (e2) tty)
           (push (cons tty ty) eqs)
           (let* ((ty1     (gen-tvar "C"))
                  (e1-goal `(,a ,e1 (:tfun (,ty1) ,ty)))
                  (e2-goal `(,a ,e2 ,ty1)))
             (wand eqs
                   si-eqs
                   `(,e1-goal ,e2-goal ,@(rest goals)))))

          ;; LAMBDA
          ((:lam ((v vty)) e tty)
           (push (cons tty ty) eqs)
           ;; v is (:evar n)
           ;; vty can be nil
           (let* ((vname (evar->str v))
                  (ty1 (gen-tvar (concatenate 'string "A-" vname)))
                  (ty2 (gen-tvar "R"))

                  (arg-ty-eqs (if vty
                                  `((,ty1 . ,vty))
                                  '()))

                  (new-eq   `(,ty . (:tfun (,ty1) ,ty2)))
                  (new-a    `(,v  . ,ty1))
                  (new-goal `((,new-a ,@a) ,e ,ty2)))
             (wand `(,new-eq ,@arg-ty-eqs ,@eqs)
                   si-eqs
                   `(,new-goal ,@(rest goals)))))

          ;; LET
          ((:let ((v e0)) e tty)
           (push (cons tty ty) eqs)
           (let+ ((ty1 (gen-tvar "V"))
                  (n   (ematch-form v ((:evar n) n)))
                  (ty2 (gen-svar (concatenate 'string (string n) "*")))

                  ((es1 si-es1) (wand eqs si-eqs `((,a ,e0 ,ty1))))

                  (new-a `(,v . ,ty2))
                  ((es2 si-es2) (wand eqs si-eqs `(((,new-a ,@a) ,e  ,ty)))))

             (wand `(,@es1 ,@es2)
                   `(,@si-es1 (:s ,ty2 ,ty1 ,a) ,@si-es2)
                   (rest goals))))))

      (list eqs si-eqs)))

(defun fh-unify (eqs &optional (sol '()))
  "Freehand implementation of a type eq constraint unifier

   Solution is a substitution that unifies the eqs:
        { sol(a) == sol(b) | a:b ∈ eqs }"
  (if eqs
      (ematch (car eqs)
        ;; a already= b
        ((guard (cons a b)
                (equal a b))
         (fh-unify (rest eqs) sol))

        ;; tvar = x | x = tvar
        ((or (cons (list :tvar n) x)
             (cons x (list :tvar n)))
         (if (occurs (list :tvar n) x)
             (error (format nil "(ERTE): Recursive type equation for ~s" n))
             (let+ ((sub `(((:tvar ,n) . ,x))))
               (fh-unify (subst-eqs sub (rest eqs))
                         (compose-subst sol sub)
                         ;;`(((:tvar ,n) . ,x) ,@(subst-sol sub sol))

                         ))))

        ;; tfun1 = tfun2
        ((cons (list :tfun (list a1) a2)
               (list :tfun (list b1) b2))

         (fh-unify `((,a1 . ,b1)
                     (,a2 . ,b2)
                     ,@(rest eqs)) sol))

        ;; bad equality
        ((cons a b)
         (error (format nil "Type mismatch: ~/wand+:show-eq/" (cons a b))))

        ;; bad form
        (_
         (error "malformed")))
      sol))

(defun inst-ieqs (ieqs ty env)
  "Generate a list of e-constraints from i-constraints

   For every i-constraint, instantiate ty with respect to env and generate an
     e-constraint: instatiated-ty =e <monotype ty of i-constr>"
  (if ieqs
      (let* ((ty-ftvs  (ftv-ty  ty))
             (env-ftvs (ftv-env env))
             (bound-vars (set-difference ty-ftvs env-ftvs :test #'equal))
             (instantiation-subst (mapcar
                                    #'(lambda (tv)
                                        (cons tv (gen-tvar "I")))
                                    bound-vars))
             (instantiated-ty (subst-ty instantiation-subst ty)))

        ; (format t "~&INST-SUBS: ~@<~{~/wand+:show-eq/~^~@:_~}~:>"
        ;         instantiation-subst)

        (ematch-form (first ieqs)
          ((:i ty1 ty2)
           (declare (ignore ty1))
           (let ((new-eq  `(,instantiated-ty . ,ty2))
                 (new-eqs (inst-ieqs (rest ieqs) ty env)))
             `(,new-eq ,@new-eqs)))))
      nil))

(defun si-unify (si-eqs)
  "SI-constraints unifier"
  ;; A   : tvar
  ;; A*  : svar
  ;; ENV : assumptions

  ;; (:S A* A ENV)
  ;; (:I A* A)
  (if si-eqs
      (ematch-form (car si-eqs)
        ((:s sty ty env)
         (let+ (((ieqs others) (partition #'(lambda (e)
                                              (and (eql  :i   (first e))
                                                   (equal sty (second e))))
                                          (rest si-eqs)))
                (eqs (inst-ieqs ieqs ty env))
                (e-subs (fh-unify eqs)))
           (compose-subst e-subs (si-unify (subst-si-eqs e-subs others))))))
      nil))

(defun solve (all-eqs)
  "Solve the system of type constraints"
  (let+ (((eqs si-eqs) all-eqs)
         (sub1 (fh-unify eqs))
         (sub2 (si-unify (subst-si-eqs sub1 si-eqs))))
    (compose-subst sub1 sub2)))

(defun occurs (ty1 ty2)
  "Occurs check. ty1 occuring in ty2"
  (ematch ty2
    ((list :tfun (list ta) tb)
     (or (occurs ty1 ta)
         (occurs ty1 tb)))

    ((guard ta
            (equal ta ty1)) t)
    (_ nil)
    ))

(defun subst-ty (sub ty)
  "Apply substitution to all free variables in ty"
  (ematch ty
    ((list :tvar _)
     (cdr (or (assoc ty sub :test #'equal)
              (cons nil ty))))

    ;; TODO: verify if this is correct
    ((list :svar _) ty)


    ((list :builtin _) ty)

    ((list :tfun (list ty1) ty2)
     (list :tfun (list (subst-ty sub ty1)) (subst-ty sub ty2)))))

(defun subst-env (sub env)
  "Apply substitution to right hand side of env"
  (mapcar #'(lambda (p) (cons (car p)
                              (subst-ty sub (cdr p))))
          env))

(defun subst-eqs (sub eqs)
  "Apply substitution to both sides of all equations in eqs"
  (mapcar #'(lambda (p) (cons (subst-ty sub (car p))
                              (subst-ty sub (cdr p))))
          eqs))

(defun subst-si-eqs (sub si-eqs)
  "Apply substitution to si-equation constraints"
  (mapcar #'(lambda (l)
              (ematch-form l
                ((:s ty1 ty2 a)
                 `(:s ,ty1 ,(subst-ty sub ty2) ,(subst-env sub a)))
                ((:i ty1 ty2)
                 `(:i ,ty1 ,(subst-ty sub ty2)))))
          si-eqs))

; (defun subst-sol (sub sol)
;   "Apply substitution to rhs of all equations in sol"
;   (mapcar #'(lambda (p) (cons (car p)
;                               (subst-ty sub (cdr p))))
;           sol))

(defun subst-ast (sub ast)
  "Walk through ast and replace tvars according to the substitution"
  (ematch-form ast
    ((:evar n tty)
     (list :evar n (subst-ty sub tty)))
    ((:lit tn v)
     (list :lit tn v))

    ((:call e1 (e2) tty)
     (let ((e1 (subst-ast sub e1))
           (e2 (subst-ast sub e2))
           (tty (subst-ty sub tty)))
       `(:call ,e1 (,e2) ,tty)))

    ((:lam ((v vty)) e tty)
     (let ((e   (subst-ast sub e))
           (tty (subst-ty sub tty)))
       `(:lam ((,v ,vty)) ,e ,tty)))

    ((:let ((v e0)) e tty)
     (let ((e0  (subst-ast sub e0))
           (e   (subst-ast sub e))
           (tty (subst-ty sub tty)))
       `(:let ((,v ,e0)) ,e ,tty)))))

(defun compose-subst (sub1 sub2)
  "Compose two substitutions such that (s2 ∘ s1)(x) = s2(s1(x))"
  (nconc
    (mapcar #'(lambda (p) (cons (car p)
                                (subst-ty sub2 (cdr p))))
            sub1)
    sub2))

(defun ftv-env (env)
  "Get the free type vars from env (assumptions)"
  (if env
      ;; (first env) => (evar . ty)
      (append (ftv-ty  (cdr (first env)))
              (ftv-env (rest env)))
      nil))

(defun ftv-ty (ty)
  "Get the free type vars from type ty"
  (ematch-form ty
    ((:tvar tn) (declare (ignore tn)) (list ty))
    ((:svar tn) (declare (ignore tn)) '())
    ((:builtin tn) (declare (ignore tn)) '())
    ((:tfun (ty0) ty1) (union (ftv-ty ty0)
                              (ftv-ty ty1)
                              :test #'equal))))

(defun wand-infer (expr &optional tvar)
  "Generate a set of type equations for an expression using Wand's algorithm"
  (let ((tvar (or tvar (gen-tvar "T"))))
    (wand '() '() `((() ,expr ,tvar)))))

;;=============================================================================

(defparameter *pprint-tvars* nil)
(defun show-ty (s ty &optional colonp atp)
  "Aesthetically write ty to stream s.
   COLONP: declare this to be a toplevel and so don't
            put parens around ty if ty is a function

   *pprint-tvars*:
         print pretty names for tvars instead of directly printing the symbols
         (This uses the *pretty-tnames* and *pretty-tnames-counter* params)"
  (declare (ignore atp))
  (ematch-form ty
    ((:tvar n)
     (format s "~a" (if *pprint-tvars*
                        (pretty-tvar n)
                        n)))

    ((:builtin n)
     (format s "~a" n))

    ((:tfun (ty1) ty2)
     (unless colonp
       (princ "(" s))

     (show-ty s ty1 nil)
     (princ " -> " s)
     (show-ty s ty2 nil)

     (unless colonp
       (princ ")" s))))
  nil)

(defparameter *pretty-tnames* (make-hash-table))
(defparameter *pretty-tnames-counter* 0)
(defun num->letters (num)
  "Return a for 0 and z for 25. Every wrap adds a letter: 26 => aa, 27 => bb"
  (let* ((numchars (1+ (floor (/ num 26))))
         (letter   (mod num 26))
         (lchar    (code-char (+ letter (char-code #\a)))))
    (make-string numchars :initial-element lchar)))

(defun pretty-tvar (n)
  "Return a pretty string uniquely for the symbol n"
  (let ((pn (gethash n *pretty-tnames*)))
    (unless pn
      (setf pn (num->letters *pretty-tnames-counter*))
      (setf (gethash n *pretty-tnames*) pn)
      (incf *pretty-tnames-counter*))
    pn))

(defmacro with-fresh-tvars (&body body)
  `(let ((*gen-tvar-counter* 0)
         (*pretty-tnames* (make-hash-table))
         (*pretty-tnames-counter* 0))
     ,@body))

(defun show-eq (s e &rest r)
  (declare (ignore r))
  (format s "~:/wand+:show-ty/ = ~:/wand+:show-ty/" (car e) (cdr e)))

(defun show-eqs (s eqs &rest r)
  (declare (ignore r))
  (format s "~{~/wand+:show-eq/~%~}" eqs))

(defparameter *show-ast-compact* t)
(defun show-ast (s ast &rest r)
  (declare (ignore r))
  (ematch-form ast
    ((:evar n tty)
     (format s "~A #:: ~/wand+:show-ty/" n tty))
    ((:lit tn v)
     (format s "~A #:: ~/wand+:show-ty/" v tn))

    ((:call e1 (e2) tty)
     (if *show-ast-compact*
         (loop with e = ast
               with args = '()
               while (eql :call (first e))
               do (let+ (((e1 (e2) _) (rest e)))
                    (declare (ignore _))
                    (push e2 args)
                    (setf e e1))
               finally (format s "~:<~
                                  ~{~/wand+:show-ast/~^~_ ~}~
                                  ~:> #:: ~/wand+:show-ty/"
                               (list (cons e args)) tty))

         (format s "~:<~/wand+:show-ast/~@:_~
                    ~/wand+:show-ast/~
                    ~:> #:: ~/wand+:show-ty/"
                 (list e1 e2) tty)))

  ((:lam ((v vty)) e tty)
   (declare (ignore vty))
   (if *show-ast-compact*
       (loop with e = ast
             with args = '()
             while (eql :lam (first e))
             do (let+ (((((v vty)) e1 tty) (rest e)))
                  (declare (ignore vty tty))
                  (push (second v) args)
                  (setf e e1))
             finally (format s "~:<lam (~{~s~^ ~})~_ ~
                                ~/wand+:show-ast/~
                                ~:> #:: ~/wand+:show-ty/"
                             (list (reverse args) e) tty))

   (format s "~:<lam (~s)~_ ~
              ~/wand+:show-ast/~
              ~:> #:: ~/wand+:show-ty/"
           (list (second v) e) tty)))

    ((:let ((v e0)) e tty)
     (if *show-ast-compact*
         (loop with e = ast
               with binds = '()
               while (eql :let (first e))
               do (let+ (((((v e0)) e1 tty) (rest e)))
                    (declare (ignore tty))
                    (push (list (second v) e0) binds)
                    (setf e e1))
               finally (format s "~:<let (~{~:<~s ~/wand+:show-ast/~:>~^~_~})~_ ~
                                  ~/wand+:show-ast/~
                                  ~:>"
                               (list (reverse binds) e)))

     (format s
             "~:<let (~s ~/wand+:show-ast/)~_ ~
              ~/wand+:show-ast/~
              ~:> #:: ~/wand+:show-ty/"
             (list (second v) e0 e) tty)))))


;;=============================================================================

(defun pretty->ast (pretty)
  (flet ((sym=str (sym str) (and (symbolp sym)
                                 (string= (string sym) str))))
    (ematch pretty
      ((list (guard s (sym=str s "LAM"))
             bindings
             e)
       (ematch (first bindings)
         ((or (list v vty)
             (and v (<> vty nil)))
          (let ((arg (if vty
                         `((:evar ,v) (:builtin ,vty))
                         `((:evar ,v) nil))))
            `(:lam (,arg)
              ,(if (rest bindings)
                   (pretty->ast `(lam ,(rest bindings) ,e))
                   (pretty->ast e))
              ,(gen-tvar "target"))))))

      ((list (guard s (sym=str s "LET"))
             bindings
             e)
       (let+ (((x e0) (first bindings)))
         `(:let (((:evar ,x) ,(pretty->ast e0)))
           ,(if (rest bindings)
                (pretty->ast `(let ,(rest bindings) ,e))
                (pretty->ast e))
           ,(gen-tvar "target"))))

      ((cons e1 args)
        (let ((e2 (first args)))
          (if (rest args)
              (pretty->ast `((,e1 ,e2) ,@(rest args)))
              `(:call ,(pretty->ast e1) (,(pretty->ast e2))
                ,(gen-tvar "target")))))

      ((guard x (symbolp x)) (match (string x)
                               ("TRUE"  `(:lit (:builtin bool) :true))
                               ("FALSE" `(:lit (:builtin bool) :false))
                               (_       `(:evar ,x ,(gen-tvar "target")))))
      ((guard x (numberp x)) `(:lit (:builtin int) ,x))

      (m (error (format nil "(EIS): Invalid syntax: ~s" m))))))

(defun pretty->ty+ (pretty)
  "Return the solution substitution set"
  (let* ((ast (pretty->ast pretty))
         (sol (solve (wand-infer ast))))
    (values
      sol
      (subst-ast sol ast))))

(defun pretty->ty (pretty)
  "Return the type of the toplevel expr"
  (let* ((top (gen-tvar "TOP"))
         (ast (pretty->ast pretty))
         (res (solve (wand-infer ast top))))
    (cdr (assoc top res :test #'equal))))

(defun pretty->ty-show+ (pretty &key (pprint-tvars t))
  "Pretty-print the solution substitution set"
  (with-fresh-tvars
    (let+ (((&values res ast) (pretty->ty+ pretty)))
      (fresh-line)
      (show-eqs t res nil nil)
      (fresh-line)
      (let ((*pprint-tvars* pprint-tvars))
        (show-ast t ast)))))

(defun pretty->ty-show (pretty)
  "Pretty-print the type of the toplevel expr"
  (with-fresh-tvars
    (let ((res (pretty->ty pretty))
          (*pprint-tvars* t))
      (fresh-line)
      (show-ty t res t))))

;;=============================================================================

;; Examples:

#+nil
(pretty->ty-show+ '(let ((S (lam (x y z) ((x z) (y z))))
                         (K (lam (q i) q))
                         (I (lam (x) x))
                         (II (lam (p) (I I p)))

                         ;; The reverse operator
                         (reverse ((S (K (S I))) K)))

                     ; ((reverse 123) I)
                     ; (reverse 123)
                     ; ((reverse 123) II)
                     ; (II 123)
                     (reverse 123 II)
                     )
                  ; :pprint-tvars t
                  )

#+nil
(pretty->ty-show+ '(let ((S (lam (x) (lam (y) (lam (z) ((x z) (y z))))))
                         (K (lam (q) (lam (i) q)))
                         (I (lam (x) x))

                         (II (lam (p) ((I I) p)))

                         ;; The reverse operator
                         (reverse ((S (K (S I))) K)))

                     ; ((reverse 123) I)
                     ; (reverse 123)
                     ((reverse 123) II)
                     )
                  ; :pprint-tvars t
                  )

#+nil
(pretty->ty-show+ '(let ((S (lam (x) (lam (y) (lam (z) ((x z) (y z)))))))
                    (let ((K (lam (q) (lam (i) q))))
                      (let ((I (lam (x) x)))

                        ;; The reverse operator
                        (let ((reverse ((S (K (S I))) K)))
                          ; ((reverse 123) I)
                          ; (reverse 123)
                          (let ((II (lam (p) ((I I) p))))
                            ((reverse 123) II)
                            )
                          ))))
                  ; :pprint-tvars t
                  )

#+nil
(pretty->ty-show '(let ((S (lam (x) (lam (y) (lam (z) ((x z) (y z))))))
                        (K (lam (q) (lam (i) q)))
                        (I (lam (x) x)))

                    ;; The reverse combinator
                    (let ((reverse ((S (K (S I))) K)))
                      ; ((reverse 123) I)
                      (reverse 123)
                      )))
